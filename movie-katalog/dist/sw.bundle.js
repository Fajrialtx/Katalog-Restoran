/*! For license information please see sw.bundle.js.LICENSE.txt */
(() => {
  const t = 'restaurantcatalogue-V1'; function e(t) { return e = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; }, e(t); } function r() {
    r = function () { return n; }; let t; var n = {}; const o = Object.prototype; const i = o.hasOwnProperty; const a = Object.defineProperty || function (t, e, r) { t[e] = r.value; }; const c = typeof Symbol === 'function' ? Symbol : {}; const u = c.iterator || '@@iterator'; const s = c.asyncIterator || '@@asyncIterator'; const f = c.toStringTag || '@@toStringTag'; function h(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r, enumerable: !0, configurable: !0, writable: !0,
      }), t[e];
    } try { h({}, ''); } catch (t) { h = function (t, e, r) { return t[e] = r; }; } function l(t, e, r, n) { const o = e && e.prototype instanceof w ? e : w; const i = Object.create(o.prototype); const c = new N(n || []); return a(i, '_invoke', { value: S(t, r, c) }), i; } function p(t, e, r) { try { return { type: 'normal', arg: t.call(e, r) }; } catch (t) { return { type: 'throw', arg: t }; } }n.wrap = l; const v = 'suspendedStart'; const y = 'suspendedYield'; const d = 'executing'; const g = 'completed'; const m = {}; function w() {} function x() {} function b() {} let L = {}; h(L, u, (function () { return this; })); const E = Object.getPrototypeOf; const k = E && E(E(T([]))); k && k !== o && i.call(k, u) && (L = k); const O = b.prototype = w.prototype = Object.create(L); function j(t) { ['next', 'throw', 'return'].forEach(((e) => { h(t, e, (function (t) { return this._invoke(e, t); })); })); } function _(t, r) { function n(o, a, c, u) { const s = p(t[o], t, a); if (s.type !== 'throw') { const f = s.arg; const h = f.value; return h && e(h) == 'object' && i.call(h, '__await') ? r.resolve(h.__await).then(((t) => { n('next', t, c, u); }), ((t) => { n('throw', t, c, u); })) : r.resolve(h).then(((t) => { f.value = t, c(f); }), ((t) => n('throw', t, c, u))); }u(s.arg); } let o; a(this, '_invoke', { value(t, e) { function i() { return new r(((r, o) => { n(t, e, r, o); })); } return o = o ? o.then(i, i) : i(); } }); } function S(e, r, n) { let o = v; return function (i, a) { if (o === d) throw Error('Generator is already running'); if (o === g) { if (i === 'throw') throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a; ;) { const c = n.delegate; if (c) { const u = C(c, n); if (u) { if (u === m) continue; return u; } } if (n.method === 'next')n.sent = n._sent = n.arg; else if (n.method === 'throw') { if (o === v) throw o = g, n.arg; n.dispatchException(n.arg); } else n.method === 'return' && n.abrupt('return', n.arg); o = d; const s = p(e, r, n); if (s.type === 'normal') { if (o = n.done ? g : y, s.arg === m) continue; return { value: s.arg, done: n.done }; }s.type === 'throw' && (o = g, n.method = 'throw', n.arg = s.arg); } }; } function C(e, r) { const n = r.method; const o = e.iterator[n]; if (o === t) return r.delegate = null, n === 'throw' && e.iterator.return && (r.method = 'return', r.arg = t, C(e, r), r.method === 'throw') || n !== 'return' && (r.method = 'throw', r.arg = new TypeError(`The iterator does not provide a '${n}' method`)), m; const i = p(o, e.iterator, r.arg); if (i.type === 'throw') return r.method = 'throw', r.arg = i.arg, r.delegate = null, m; const a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, r.method !== 'return' && (r.method = 'next', r.arg = t), r.delegate = null, m) : a : (r.method = 'throw', r.arg = new TypeError('iterator result is not an object'), r.delegate = null, m); } function P(t) { const e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function G(t) { const e = t.completion || {}; e.type = 'normal', delete e.arg, t.completion = e; } function N(t) { this.tryEntries = [{ tryLoc: 'root' }], t.forEach(P, this), this.reset(!0); } function T(r) { if (r || r === '') { const n = r[u]; if (n) return n.call(r); if (typeof r.next === 'function') return r; if (!isNaN(r.length)) { let o = -1; const a = function e() { for (;++o < r.length;) if (i.call(r, o)) return e.value = r[o], e.done = !1, e; return e.value = t, e.done = !0, e; }; return a.next = a; } } throw new TypeError(`${e(r)} is not iterable`); } return x.prototype = b, a(O, 'constructor', { value: b, configurable: !0 }), a(b, 'constructor', { value: x, configurable: !0 }), x.displayName = h(b, f, 'GeneratorFunction'), n.isGeneratorFunction = function (t) { const e = typeof t === 'function' && t.constructor; return !!e && (e === x || (e.displayName || e.name) === 'GeneratorFunction'); }, n.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, b) : (t.__proto__ = b, h(t, f, 'GeneratorFunction')), t.prototype = Object.create(O), t; }, n.awrap = function (t) { return { __await: t }; }, j(_.prototype), h(_.prototype, s, (function () { return this; })), n.AsyncIterator = _, n.async = function (t, e, r, o, i) { void 0 === i && (i = Promise); const a = new _(l(t, e, r, o), i); return n.isGeneratorFunction(e) ? a : a.next().then(((t) => (t.done ? t.value : a.next()))); }, j(O), h(O, f, 'Generator'), h(O, u, (function () { return this; })), h(O, 'toString', (() => '[object Generator]')), n.keys = function (t) { const e = Object(t); const r = []; for (const n in e)r.push(n); return r.reverse(), function t() { for (;r.length;) { const n = r.pop(); if (n in e) return t.value = n, t.done = !1, t; } return t.done = !0, t; }; }, n.values = T, N.prototype = {
      constructor: N, reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = 'next', this.arg = t, this.tryEntries.forEach(G), !e) for (const r in this)r.charAt(0) === 't' && i.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop() { this.done = !0; const t = this.tryEntries[0].completion; if (t.type === 'throw') throw t.arg; return this.rval; }, dispatchException(e) { if (this.done) throw e; const r = this; function n(n, o) { return c.type = 'throw', c.arg = e, r.next = n, o && (r.method = 'next', r.arg = t), !!o; } for (let o = this.tryEntries.length - 1; o >= 0; --o) { const a = this.tryEntries[o]; var c = a.completion; if (a.tryLoc === 'root') return n('end'); if (a.tryLoc <= this.prev) { const u = i.call(a, 'catchLoc'); const s = i.call(a, 'finallyLoc'); if (u && s) { if (this.prev < a.catchLoc) return n(a.catchLoc, !0); if (this.prev < a.finallyLoc) return n(a.finallyLoc); } else if (u) { if (this.prev < a.catchLoc) return n(a.catchLoc, !0); } else { if (!s) throw Error('try statement without catch or finally'); if (this.prev < a.finallyLoc) return n(a.finallyLoc); } } } }, abrupt(t, e) { for (let r = this.tryEntries.length - 1; r >= 0; --r) { const n = this.tryEntries[r]; if (n.tryLoc <= this.prev && i.call(n, 'finallyLoc') && this.prev < n.finallyLoc) { var o = n; break; } }o && (t === 'break' || t === 'continue') && o.tryLoc <= e && e <= o.finallyLoc && (o = null); const a = o ? o.completion : {}; return a.type = t, a.arg = e, o ? (this.method = 'next', this.next = o.finallyLoc, m) : this.complete(a); }, complete(t, e) { if (t.type === 'throw') throw t.arg; return t.type === 'break' || t.type === 'continue' ? this.next = t.arg : t.type === 'return' ? (this.rval = this.arg = t.arg, this.method = 'return', this.next = 'end') : t.type === 'normal' && e && (this.next = e), m; }, finish(t) { for (let e = this.tryEntries.length - 1; e >= 0; --e) { const r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), G(r), m; } }, catch(t) { for (let e = this.tryEntries.length - 1; e >= 0; --e) { const r = this.tryEntries[e]; if (r.tryLoc === t) { const n = r.completion; if (n.type === 'throw') { var o = n.arg; G(r); } return o; } } throw Error('illegal catch attempt'); }, delegateYield(e, r, n) { return this.delegate = { iterator: T(e), resultName: r, nextLoc: n }, this.method === 'next' && (this.arg = t), m; },
    }, n;
  } function n(t, e, r, n, o, i, a) { try { var c = t[i](a); var u = c.value; } catch (t) { return void r(t); }c.done ? e(u) : Promise.resolve(u).then(n, o); } function o(t) { return function () { const e = this; const r = arguments; return new Promise(((o, i) => { const a = t.apply(e, r); function c(t) { n(a, o, i, c, u, 'next', t); } function u(t) { n(a, o, i, c, u, 'throw', t); }c(void 0); })); }; } const i = {
    cachingAppShell(t) { const e = this; return o(r().mark((function n() { return r().wrap(((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, e.openCache(); case 2: r.sent.addAll(t); case 4: case 'end': return r.stop(); } }), n); })))(); }, deleteOldCache() { return o(r().mark((function e() { return r().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.next = 2, caches.keys(); case 2: e.sent.filter(((e) => e !== t)).map(((t) => caches.delete(t))); case 4: case 'end': return e.stop(); } }), e); })))(); }, revalidateCache(t) { const e = this; return o(r().mark((function n() { let o; return r().wrap(((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, caches.match(t); case 2: if (!(o = r.sent)) { r.next = 6; break; } return e.fetchRequest(t), r.abrupt('return', o); case 6: return r.abrupt('return', e.fetchRequest(t)); case 7: case 'end': return r.stop(); } }), n); })))(); }, openCache() { return o(r().mark((function e() { return r().wrap(((e) => { for (;;) switch (e.prev = e.next) { case 0: return e.abrupt('return', caches.open(t)); case 1: case 'end': return e.stop(); } }), e); })))(); }, fetchRequest(t) { const e = this; return o(r().mark((function n() { let o; return r().wrap(((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, fetch(t); case 2: if ((o = r.sent) && o.status === 200) { r.next = 5; break; } return r.abrupt('return', o); case 5: return r.next = 7, e.addCache(t); case 7: return r.abrupt('return', o); case 8: case 'end': return r.stop(); } }), n); })))(); }, addCache(t) { const e = this; return o(r().mark((function n() { return r().wrap(((r) => { for (;;) switch (r.prev = r.next) { case 0: return r.next = 2, e.openCache(); case 2: r.sent.add(t); case 4: case 'end': return r.stop(); } }), n); })))(); },
  }; const a = ['./', './icons/icon-72x72.png', './icons/icon-96x96.png', './icons/icon-128x128.png', './icons/icon-144x144.png', './icons/icon-152x152.png', './icons/icon-192x192.png', './icons/icon-384x384.png', './icons/icon-512x512.png', './index.html', './favicon.png', './app.bundle.js', './app.webmanifest', './sw.bundle.js']; self.addEventListener('install', ((t) => { t.waitUntil(i.cachingAppShell([].concat(a))); })), self.addEventListener('activate', ((t) => { t.waitUntil(i.deleteOldCache()); })), self.addEventListener('fetch', ((t) => { t.respondWith(i.revalidateCache(t.request)); }));
})();
// # sourceMappingURL=sw.bundle.js.map
